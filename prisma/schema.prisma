generator client {
  provider = "prisma-client-js"
  previewFeatures = ["referentialActions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model WaitList {
  id        String   @id @default(uuid())
  value     String   @unique
  approved  Boolean
  schoolId  String
  role      Role     @default(manager)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  school    School   @relation(fields: [schoolId], references: [id])
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresIn Int
  user      User     @relation(fields: [userId], references: [id])
}

model User {
  id            String         @id @default(uuid())
  name          String
  email         String         @unique
  password      String
  birthDate     DateTime
  phone         String
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  gender        Gender
  type          TypeUser
  avatar        String?
  recoverToken  String?
  address       Address[]
  admin         Admin?
  manager       Manager?
  refreshTokens RefreshToken[]
  student       Student?
  teacher       Teacher?
}

model Student {
  id                 String               @id @default(uuid())
  schoolId           String
  status             Boolean
  enrollment         String
<<<<<<< HEAD
  class              Class                @relation(fields: [classId], references: [id], onDelete: Cascade)
=======
>>>>>>> develop
  classId            String
  entryForm          String
  reasonForTransfer  String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  userId             String               @unique
  class              Class                @relation(fields: [classId], references: [id])
  school             School               @relation(fields: [schoolId], references: [id])
  user               User                 @relation(fields: [userId], references: [id])
  EvaluativeDelivery EvaluativeDelivery[]
  LackOfClass        LackOfClass[]
}

model Manager {
  id        String   @id @default(uuid())
  status    Boolean
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
  schools   School[]
}

model Admin {
  id        String   @id @default(uuid())
  status    Boolean
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id])
}

model Teacher {
  id          String       @id @default(uuid())
  status      Boolean
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  userId      String       @unique
  user        User         @relation(fields: [userId], references: [id])
  disciplines Discipline[]
  schools     School[]
}

model School {
  id        String     @id @default(uuid())
  name      String
  phone     String
  cnpj      String?    @unique
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  email     String
  inep      String?
  address   Address[]
  classes   Class[]
  Period    Period[]
  students  Student[]
  waitist   WaitList[]
  managers  Manager[]
  teachers  Teacher[]
}

model Discipline {
  id            String                @id @default(uuid())
  name          String
  teacherId     String
<<<<<<< HEAD
  class         Class                 @relation(fields: [classId], references: [id], onDelete: Cascade)
  classId       String
  topic         String
  lessons       Lesson[]
  homeWorks     HomeWork[]
  schedules     DisciplineSchedules[]
  registerClass RegisterClass[]
=======
>>>>>>> develop
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  classId       String
  topic         String
  class         Class                 @relation(fields: [classId], references: [id])
  teacher       Teacher               @relation(fields: [teacherId], references: [id])
  Content       Content[]
  schedules     DisciplineSchedules[]
  homeWorks     HomeWork[]
  lessons       Lesson[]
  registerClass RegisterClass[]
}

model Class {
  id          String       @id @default(uuid())
  name        String
  schooldId   String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  school      School       @relation(fields: [schooldId], references: [id])
  disciplines Discipline[]
  students    Student[]
}

model HomeWork {
  id                 String               @id @default(uuid())
  name               String
  description        String
  disciplineId       String
  discipline         Discipline           @relation(fields: [disciplineId], references: [id])
  dueDate            DateTime?
  isOpen             Boolean?
  attachement        String?
  type               TypeHomeWork
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  weight             Float?               @default(1)
  evaluativeDelivery EvaluativeDelivery[]
}

model EvaluativeDelivery {
  id          String           @id @default(uuid())
  studentId   String
  student     Student          @relation(fields: [studentId], references: [id])
  homeWorkId  String
  homeWork    HomeWork         @relation(fields: [homeWorkId], references: [id])
  dueDate     DateTime?
  attachement String?
  stage       EvaluationStage?
  owner       OwnerAction
  rate        Float?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
}

model Period {
  id                    String               @id @default(uuid())
  startOfPeriod         DateTime
  endOfPeriod           DateTime
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  name                  String
  schoolId              String
  disciplineSchedulesId String?
  disciplineSchedules   DisciplineSchedules? @relation(fields: [disciplineSchedulesId], references: [id])
  school                School               @relation(fields: [schoolId], references: [id])
  contents              Content[]
  registerClass         RegisterClass[]
}

model Content {
  id            String          @id @default(uuid())
  name          String
  subContent    String
  periodId      String
  disciplineId  String
  discipline    Discipline      @relation(fields: [disciplineId], references: [id])
  Period        Period          @relation(fields: [periodId], references: [id])
  registerClass RegisterClass[]
}

model RegisterClass {
  id           String            @id @default(uuid())
  classDate    DateTime
  type         TypeRegisterClass
  content      String?
  subContent   String?
  periodId     String?
  observation  String
  disciplineId String?
  contentId    String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  Content      Content?          @relation(fields: [contentId], references: [id])
  Discipline   Discipline?       @relation(fields: [disciplineId], references: [id])
  Period       Period?           @relation(fields: [periodId], references: [id])
}

model LackOfClass {
  id        String   @id @default(uuid())
  lessonId  String
  studentId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lesson    Lesson   @relation(fields: [lessonId], references: [id])
  student   Student  @relation(fields: [studentId], references: [id])
}

model Lesson {
  id           String        @id @default(uuid())
  name         String
  description  String
  disciplineId String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  discipline   Discipline    @relation(fields: [disciplineId], references: [id])
  LackOfClass  LackOfClass[]
}

model DisciplineSchedules {
  id           String     @id @default(uuid())
  day          Day
  disciplineId String
  initialHour  String
  finishHour   String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  discipline   Discipline @relation(fields: [disciplineId], references: [id])
  periods      Period[]
}

model Address {
  id           String   @id @default(uuid())
  labelAddress String
  city         String
  number       String
  area         String
  uf           String
  zipCode      String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  street       String
  schoolId     String?
  userId       String?
  school       School?  @relation(fields: [schoolId], references: [id])
  user         User?    @relation(fields: [userId], references: [id])
}

enum Gender {
  male @map("Masculino")
  female @map("Feminino")
  notBinary @map("Não Binário")
  others @map("Outros")
  notInform @map("Prefiro Não Informar")
}

enum Role {
  admin @map("Administrador")
  manager @map("Gestor")
  teacher @map("Professor")
  others @map("Outros")
  student @map("Estudante")
}

enum TypeUser {
  admin @map("Administrador")
  manager @map("Gestor")
  teacher @map("Professor")
  student @map("Estudante")
  others @map("Outros")
}

enum TypeRegisterClass {
  planEducation @map("Plano de Ensino")
  loose @map("Avulso")
}

enum Day {
  monday @map("Segunda-Feira")
  thursday @map("Terça-Feira")
  wednesday @map("Quarta-Feira")
  tuesday @map("Quinta-Feira")
  friday @map("Sexta-Feira")
  saturday @map("Sábado")
  sunday @map("Domingo")
}

enum TypeHomeWork {
  activity @map("Atividade")
  exame @map("Prova")
  work @map("Trabalho")
  others @map("Outros")
  test @map("Avaliação")
}

enum EvaluationStage {
  sent @map("Enviada")
  overdue @map("Atrasada")
  pending @map("Pendente")
  evaluated @map("Avaliada")
  canceled @map("Cancelada")
  others @map("Outros")
}

enum OwnerAction {
  teacher @map("Professor")
  student @map("Estudante")
}
